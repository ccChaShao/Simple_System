-- @Author: Charlie
-- @Email: 203981473@qq.com
-- @Description: DRedDotModule class for managing the RedDot system and its nodes.
-- @Date: 2025-04-17 11:04:22
-- @Modify:

-- 导入BaseClass
local BaseClass = require("BaseClass")

DRedDotModule = {}
setmetatable(DRedDotModule,BaseClass)
DRedDotModule.__index = DRedDotModule

function DRedDotModule:new()
    local self = BaseClass:new()
    setmetatable(self, DRedDotModule)
    self.m_Root = nil
    self.m_Nodes = {}
    self.m_Pattern = "_"
    self.m_DirtyViewNodes = {}
    self.m_ChangedLeafNodes = {}
    return self
end

function DRedDotModule:Initialize(root, nodeMap, pattern)
    self.m_Pattern = pattern or "_"
    self.m_Root = DRedDotNode:new(root, nil)
    for _, node in ipairs(nodeMap) do
        local currentNode = self.m_Root
        local keys = self:SplitAndTrim(node, self.m_Pattern)
        for i = 2, #keys do
            local key = keys[i]
            local newNode = currentNode:AddChild(key)
            currentNode = newNode
        end
    end
end

function DRedDotModule:AddRedDotNodeViewCallBack(nodeStr, callback)
    local node = self:GetRedDotNode(nodeStr)
    if node then
        node.OnUpdateViewEvent = callback
    end
end

function DRedDotModule:RemoveRedDotNodeViewCallBack(nodeStr, callback)
    local node = self:GetRedDotNode(nodeStr)
    if node then
        node.OnUpdateViewEvent = nil
    end
end

function DRedDotModule:UpdateRedDotCountDelay(nodeStr, count)
    local node = self:GetRedDotNode(nodeStr)
    if not node then return end 
    self.m_ChangedLeafNodes[node] = count
    local items = node:GetAllAffectedParentNodes()
    if items and #items > 0 then
        for _, item in ipairs(items) do
            table.insert(self.m_DirtyViewNodes, item)
        end
    end
end

function DRedDotModule:UpdateRedDotCount(nodeStr, count)
    local node = self:GetRedDotNode(nodeStr)
    if node then
        node:UpdateRedDotCount(count)
    end
end

function DRedDotModule:ClearRootAllNode()
    local list = self:GetRedDotNodeChildren(self.m_Root)
    for _, cNode in ipairs(list) do
        cNode:ClearRedDotCountSilently(0)
    end
    self.m_Root:UpdateRedDot()
end

function DRedDotModule:ClearRedDotNode(nodeStr)
    local node = self:GetRedDotNode(nodeStr)
    if not node then return end
    local list = self:GetRedDotNodeChildren(node)
    for _, cNode in ipairs(list) do
        cNode:ClearRedDotCountSilently(0)
    end
    node:UpdateRedDot()
end

function DRedDotModule:Update()
    if #self.m_ChangedLeafNodes == 0 then return end
    for node, count in pairs(self.m_ChangedLeafNodes) do
        node:UpdateRedDotDelay(count)
    end
    table.sort(self.m_DirtyViewNodes, function(a, b) return a.Level > b.Level end)
    for _, node in ipairs(self.m_DirtyViewNodes) do
        node:UpdateRedDotDelay()
    end
    self.m_ChangedLeafNodes = {}
    self.m_DirtyViewNodes = {}
end

function DRedDotModule:GetRedDotNode(nodeStr)
    if not nodeStr or nodeStr == "" then return nil end
    if nodeStr == self.m_Root.Name then return self.m_Root end
    local node = self.m_Root
    local keys = self:SplitAndTrim(nodeStr, self.m_Pattern)
    for i = 2, #keys do
        local key = keys[i]
        if not node.Children[key] then
            return nil
        end
        node = node.Children[key]
    end
    return node
end

function DRedDotModule:GetRedDotNodeChildren(root)
    local list = {}
    self:Traverse(root, list, false)
    return list
end

function DRedDotModule:RedDotModuleDebug()
    local result = {}
    self:TraverseNodeDebug(self.m_Root, 0, result)
    print(table.concat(result))
end

function DRedDotModule:TraverseNodeDebug(node, level, result)
    local sb = ""
    for i = 1, level do
        sb = sb .. "|    "
    end
    if level > 0 then
        sb = sb .. "|----"
    end
    local leaf = node.IsLeaf and "----leaf" or ""
    sb = sb .. node.Name .. "\t" .. node.Count .. "\t" .. leaf .. "\n"
    table.insert(result, sb)
    for _, childNode in pairs(node.Children) do
        self:TraverseNodeDebug(childNode, level + 1, result)
    end
end

function DRedDotModule:Traverse(node, list, isLeaf)
    if not node then return end
    local stack = {node}
    while #stack > 0 do
        local currentNode = table.remove(stack)
        for _, child in pairs(currentNode.Children) do
            if isLeaf then
                if child.IsLeaf then
                    table.insert(list, child)
                end
            else
                table.insert(list, child)
            end
            table.insert(stack, child)
        end
    end
end

function DRedDotModule:SplitAndTrim(input, separators)
    if not input or input == "" then return {} end
    if not separators or #separators == 0 then
        separators = {" "}
    end
    local result = {}
    for s in string.gmatch(input, "[^" .. separators .. "]+") do
        table.insert(result, s:trim())
    end
    return result
end